// ---------------------------------------------------------------------------
// Preconditions.java
// Generate preconditions of function/operation applications.
// $Id: Preconditions.java,v 1.19 2018/06/06 15:06:21 schreine Exp $
//
// Author: Wolfgang Schreiner <Wolfgang.Schreiner@risc.jku.at>
// Copyright (C) 2018-, Research Institute for Symbolic Computation (RISC)
// Johannes Kepler University, Linz, Austria, http://www.risc.jku.at
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// ----------------------------------------------------------------------------
package riscal.tasks;

import java.util.*;

import riscal.syntax.*;
import riscal.syntax.AST.*;
import riscal.syntax.AST.Expression.*;
import riscal.syntax.AST.Type.*;
import riscal.types.Environment.Symbol.*;
import riscal.tasks.Validation.Condition;

public class Preconditions extends ASTVisitor.Base<Void>
{  
  /****************************************************************************
   * Generate list of preconditions arising from the evaluation of exp.
   * @param exp the expression.
   * @param fun the function in whose body exp arises
   * @param callers the caller map
   * @return the list of preconditions.
   ***************************************************************************/
  public static List<Condition> generate(Expression exp,
    FunctionSymbol fun, Recursion.CallMap callers)
  {
    Preconditions pre = new Preconditions(fun, callers);
    exp.accept(pre);
    return pre.conditions;
  }
  
  /****************************************************************************
   * Generate list of preconditions arising from the evaluation of qvar.
   * @param qvar the quantified variable
   * @param fun the function in whose body qvar arises
   * @param callers the caller map
   * @return the list of preconditions.
   ***************************************************************************/
  public static List<Condition> generate(QuantifiedVariable qvar,
    FunctionSymbol fun, Recursion.CallMap callers)
  {
    Preconditions pre = new Preconditions(fun, callers);
    qvar.accept(pre);
    return pre.conditions;
  }
  
  // the conditions generated by the visit
  private List<Condition> conditions = new ArrayList<Condition>();
  
  // the current function symbol, the caller map, and the function info
  private FunctionSymbol fun;
  private Recursion.CallMap callers;
  private OpInfo info;
  
  private Preconditions(FunctionSymbol fun, Recursion.CallMap callers)
  {
    this.fun = fun;
    this.callers = callers;
    this.info = OpInfo.getInfo(fun.getDefinition());
  }
  
  /****************************************************************************
   * Generate list of preconditions from expression with current caller map
   * @param exp the expression
   * @return the list of conditions
   ***************************************************************************/
  private List<Condition> generate(Expression exp)
  {
    return generate(exp, fun, callers);
  }
  
  // --------------------------------------------------------------------------
  //
  // expressions
  // 
  // --------------------------------------------------------------------------
  
  /****************************************************************************
   * Visit and expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(AndExp exp)
  {
    exp.exp1.accept(this);
    addImplications(exp.exp1, generate(exp.exp2));
    return null;
  }
    
  /****************************************************************************
   * Visit application expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ApplicationExp exp)
  {
    // recursively generate preconditions for arguments
    for (Expression e : exp.exps)
      e.accept(this);
    
    // determine function information
    FunctionSymbol fun = (FunctionSymbol)exp.ident.getSymbol();
    Declaration def = fun.getDefinition();
    OpInfo info = OpInfo.getInfo(def);
    
    // generate parameter bindings for arguments
    int n = info.param.length;
    List<Binder> binders = new ArrayList<Binder>(n);
    for (int i=0; i<n; i++)
    {
      Identifier ident = new Identifier(info.param[i].ident.string);
      binders.add(new Binder(ident, transform(exp.exps[i])));
    }
    
    // check type constraints of function parameters
    for (int i=0; i<n; i++)
    {
      ValueSymbol symbol = (ValueSymbol)info.param[i].ident.getSymbol();
      Expression c = getConstraint(symbol.type, AST.reference(symbol.ident.string), 
          exp.exps[i].getType());
      if (c == null) continue;
      c = new LetParExp(binders, c);
      Condition cond = new Condition(Condition.Kind.Application, exp.exps[i], c);
      cond.addPosition(info.param[i].getPosition());
      conditions.add(cond);
    }
          
    // check preconditions of function
    for (FunctionSpec pre : info.pre)
    {
      FunctionSpec.RequiresSpec pre0 = (FunctionSpec.RequiresSpec)pre;
      Expression c = new LetParExp(binders, pre0.exp);
      Condition cond = new Condition(Condition.Kind.Application, exp, c);
      cond.addPosition(pre.getPosition());
      conditions.add(cond);
    }
    
    // in case of non-recursive application, we are done
    if (!callers.calls(fun, this.fun)) return null;
    
    // otherwise, generate condition that measure is decreased
    Expression[] measure = info.decTerms;
    Expression[] measure0 = this.info.decTerms;
    if (measure == null || measure0 == null || measure.length != measure0.length)
    {
      // no or unsuitable measure, generate condition that lets termination proof fail
      conditions.add(new Condition(Condition.Kind.FunctionMeasureDecreased, exp, new FalseExp()));
      return null;
    }
    Expression eq = null;
    Expression exp0 = null;
    int n0 = measure.length;
    for (int i=0; i<n0; i++)
    {
      String measureid = Validation.getFunctionMeasureName(i);
      Expression m = measure[i];
      if (eq == null)
      {
        exp0 = new LessExp(m, AST.reference(measureid));
        eq = new EqualsExp(m, AST.reference(measureid));
        continue;
      }
      exp0 = new OrExp(exp0, new AndExp(eq, new LessExp(m, AST.reference(measureid))));     
      eq = new AndExp(eq, new EqualsExp(m, AST.reference(measureid)));
    }
    exp0 = new LetParExp(binders, exp0);
    conditions.add(new Condition(Condition.Kind.FunctionMeasureDecreased, exp, exp0));
    return null;
  }
  
  /****************************************************************************
   * Visit assert expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(AssertExp exp)
  {
    exp.exp1.accept(this);
    addImplications(exp.exp1, generate(exp.exp2));
    conditions.add(new Condition(Condition.Kind.Assertion, exp, transform(exp.exp1)));
    return null;
  }
  
  /****************************************************************************
   * Visit choose expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ChooseExp exp)
  {
    exp.qvar.accept(this);
    Expression exists = new ExistsExp(transform(exp.qvar), new TrueExp());
    conditions.add(new Condition(Condition.Kind.Choice, exp, exists));
    return null;
  }
  
  /****************************************************************************
   * Visit choose-in-else expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ChooseInElseExp exp)
  {
    exp.qvar.accept(this);
    addForalls(exp.qvar, generate(exp.exp1));
    exp.exp2.accept(this);
    return null;
  }
  
  /****************************************************************************
   * Visit choose-in expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ChooseInExp exp)
  {
    exp.qvar.accept(this);
    Expression exists = new ExistsExp(transform(exp.qvar), new TrueExp());
    conditions.add(new Condition(Condition.Kind.Choice, exp, exists));
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit divides expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(DividesExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    IntType type = (IntType)exp.exp2.getType();
    if (type.ivalue1 <= 0 && type.ivalue2 >= 0)
      conditions.add(new Condition(Condition.Kind.Application, exp,
          new NotEqualsExp(transform(exp.exp2), AST.number(0))));
    return null;
  }
  
  /****************************************************************************
   * Visit exists expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ExistsExp exp)
  {
    exp.qvar.accept(this);
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit forall expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ForallExp exp)
  {
    exp.qvar.accept(this);
    if (exp.exp != null) addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit if-then-else expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(IfThenElseExp exp)
  {
    exp.exp1.accept(this);
    addImplications(exp.exp1, generate(exp.exp2));
    addImplications(new NotExp(exp.exp1), generate(exp.exp3));
    return null;
  }
  
  /****************************************************************************
   * Visit implies expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ImpliesExp exp)
  {
    exp.exp1.accept(this);
    addImplications(exp.exp1, generate(exp.exp2));
    return null;
  }
  
  /****************************************************************************
   * Visit let expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(LetExp exp)
  {
    int n = exp.binder.length;
    for (int i=0; i<n; i++)
      addBinders(i, exp.binder, generate(exp.binder[i].exp));
    addBinders(n, exp.binder, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit letpar expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(LetParExp exp)
  {
    for (Binder b: exp.binder)
      b.exp.accept(this);
    addParBinders(exp.binder, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit map selection expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(MapSelectionExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    MapType type = (MapType)exp.exp1.getType();
    Expression c = getConstraint(type.type1, exp.exp2, exp.exp2.getType());
    if (c != null) 
      conditions.add(new Condition(Condition.Kind.Select, exp.exp2, c));
    return null;
  }
  
  /****************************************************************************
   * Visit map update expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(MapUpdateExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    exp.exp3.accept(this);
    MapType type = (MapType)exp.exp1.getType();
    Expression c1 = getConstraint(type.type1, exp.exp2, exp.exp2.getType());
    if (c1 != null) 
      conditions.add(new Condition(Condition.Kind.Select, exp.exp2, c1));
    Expression c2 = getConstraint(type.type2, exp.exp3, exp.exp3.getType());
    if (c2 != null) 
      conditions.add(new Condition(Condition.Kind.Update, exp, c2));
    return null;
  }
  
  /****************************************************************************
   * Visit match expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(MatchExp exp)
  {
    exp.exp.accept(this);
    boolean def = exp.pexp.length > 1;
    for (PatternExpression p : exp.pexp)  
      addPatterns(exp.exp, p, def, generate(p.exp));
    return null;
  } 
  
  /****************************************************************************
   * Visit max expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(MaxExp exp)
  {
    exp.qvar.accept(this);
    Expression exists = new ExistsExp(transform(exp.qvar), new TrueExp());
    conditions.add(new Condition(Condition.Kind.Choice, exp, exists));
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit min expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(MinExp exp)
  {
    exp.qvar.accept(this);
    Expression exists = new ExistsExp(transform(exp.qvar), new TrueExp());
    conditions.add(new Condition(Condition.Kind.Choice, exp, exists));
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit or expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(OrExp exp)
  {
    exp.exp1.accept(this);
    addImplications(new NotExp(exp.exp1), generate(exp.exp2));
    return null;
  }
  
  /****************************************************************************
   * Visit power expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(PowerExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    IntType type1 = (IntType)exp.exp1.getType();
    IntType type2 = (IntType)exp.exp2.getType();
    if (type1.ivalue1 <= 0L)
      conditions.add(new Condition(Condition.Kind.Application, exp,
          new GreaterExp(transform(exp.exp1), AST.number(0))));
    if (type2.ivalue1 <= 0L)
      conditions.add(new Condition(Condition.Kind.Application, exp,
          new GreaterExp(transform(exp.exp2), AST.number(0))));
    return null;
  }
  
  /****************************************************************************
   * Visit product expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(ProductExp exp)
  {
    exp.qvar.accept(this);
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit record update expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(RecordUpdateExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    ValueSymbol symbol = (ValueSymbol)exp.ident.getSymbol();
    Expression c = getConstraint(symbol.type, exp.exp2, exp.exp2.getType());
    if (c != null) 
      conditions.add(new Condition(Condition.Kind.Update, exp, c));
    return null;
  }
  
  /****************************************************************************
   * Visit remainder expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(RemainderExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    IntType type = (IntType)exp.exp2.getType();
    if (type.ivalue1 <= 0 && type.ivalue2 >= 0)
      conditions.add(new Condition(Condition.Kind.Application, exp,
          new NotEqualsExp(transform(exp.exp2), AST.number(0))));
    return null;
  }
  
  /****************************************************************************
   * Visit set builder expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(SetBuilderExp exp)
  {
    exp.qvar.accept(this);
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit sum expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(SumExp exp)
  {
    exp.qvar.accept(this);
    addForalls(exp.qvar, generate(exp.exp));
    return null;
  }
  
  /****************************************************************************
   * Visit tuple update expression
   * @exp the expression
   ***************************************************************************/
  public Void visit(TupleUpdateExp exp)
  {
    exp.exp1.accept(this);
    exp.exp2.accept(this);
    int index = exp.index.getInteger()-1;
    TupleType type = (TupleType)exp.exp1.getType();
    Expression c = getConstraint(type.types[index], exp.exp2, exp.exp2.getType());
    if (c != null) 
      conditions.add(new Condition(Condition.Kind.Update, exp, c));
    return null;
  }
  
  // --------------------------------------------------------------------------
  //
  // quantified Variables
  // 
  // --------------------------------------------------------------------------
  
  public Void visit(QuantifiedVariable qvar)
  {
    if (qvar.exp != null) addForalls(qvar, generate(qvar.exp));
    return null;
  }
  
  // -------------------------------------------------------------------------
  //
  // object auxiliaries
  //
  // -------------------------------------------------------------------------
 
  /***************************************************************************
   * Get the constraint for a given type to be matched by an expression 
   * of another type (assumes that both types already weakly match)
   * @param type the type to be matched
   * @param exp the expression
   * @param etype the type of the expression
   * @return the constraint (null, if none)
   **************************************************************************/
  private Expression getConstraint(Type type, Expression exp, Type etype)
  {
    return Validation.getConstraint(type, transform(exp), etype);
  }
    
  /***************************************************************************
   * Add to the preconditions implication conditions.
   * @param ante the antecedent of the implication
   * @param conds the conditions representing the consequents
   **************************************************************************/
  private void addImplications(Expression ante, List<Condition> conds)
  {
    Expression ante0 = transform(ante);
    for (Condition c : conds)
    {
      Expression ce = new ImpliesExp(ante0, c.exp);
      conditions.add(c.clone(ce));
    }
  }
  
  /***************************************************************************
   * Add to the preconditions universally quantified conditions.
   * @param ante the antecedent of the implication
   * @param conds the conditions representing the quantification body
   **************************************************************************/
  private void addForalls(QuantifiedVariable qvar, List<Condition> conds)
  {
    QuantifiedVariable qvar0 = transform(qvar);
    for (Condition c : conds)
    {
      Expression ce = new ForallExp(qvar0, c.exp);
      conditions.add(c.clone(ce));
    }
  }
  
  /***************************************************************************
   * Add to the preconditions let-bound conditions.
   * @param n the number of binders to be considered.
   * @param binder the binders
   * @param conds the conditions representing the let-bound expressions
   **************************************************************************/
  private void addBinders(int n, Binder[] binder, List<Condition> conds)
  {
    List<Binder> binder0 = new ArrayList<Binder>(n);
    for (int i=0; i<n; i++)
      binder0.add(transform(binder[i]));
    for (Condition c : conds)
    {
      Expression ce = n == 0 ? c.exp : new LetExp(binder0, c.exp);
      conditions.add(c.clone(ce));
    }
  }
  
  /***************************************************************************
   * Add to the preconditions letpar-bound conditions.
   * @param binder the binders
   * @param conds the conditions representing the let-bound expressions
   **************************************************************************/
  private void addParBinders(Binder[] binder, List<Condition> conds)
  {
    int n = binder.length;
    List<Binder> binder0 = new ArrayList<Binder>(n);
    for (int i=0; i<n; i++)
      binder0.add(transform(binder[i]));
    for (Condition c : conds)
    {
      Expression ce = n == 0 ? c.exp : new LetParExp(binder0, c.exp);
      conditions.add(c.clone(ce));
    }
  }
  
  /***************************************************************************
   * Add to preconditions pattern-matched preconditions.
   * @param exp the expression matched.
   * @param p the pattern currently considered.
   * @param def true if a default match is to be generated.
   * @param cond the pattern-matched preconditions.
   **************************************************************************/
  private void addPatterns(Expression exp,
    PatternExpression p, boolean def, List<Condition> cond)
  {
    for (Condition c: cond)
    {
      List<PatternExpression> ps = new ArrayList<PatternExpression>();
      PatternExpression p0 = patternExpression(p, c.exp);
      ps.add(p0);
      if (def && !(p0 instanceof PatternExpression.DefaultPatternExp)) 
        ps.add(new PatternExpression.DefaultPatternExp(new TrueExp()));
      conditions.add(c.clone(new MatchExp(transform(exp), ps)));
    }
  }
  
  /****************************************************************************
   * Create a new pattern expression from a given one and a new base expression.
   * @param p the pattern
   * @param exp the base expression
   * @return a pattern of the same kind as p but with base expression exp.
   ***************************************************************************/
  private PatternExpression patternExpression(PatternExpression p, 
    Expression exp)
  {
    exp = transform(exp);
    if (p instanceof PatternExpression.IdentifierPatternExp)
    {
      PatternExpression.IdentifierPatternExp p0 =
          (PatternExpression.IdentifierPatternExp)p;
      return new PatternExpression.IdentifierPatternExp(p0.ident, exp);
    }
    if (p instanceof PatternExpression.ApplicationPatternExp)
    {
      PatternExpression.ApplicationPatternExp p0 =
          (PatternExpression.ApplicationPatternExp)p;
      List<AST.Parameter> params =
          new ArrayList<AST.Parameter>(Arrays.asList(p0.params));
      return new PatternExpression.ApplicationPatternExp(p0.ident, params, exp);
    }
    return new PatternExpression.DefaultPatternExp(exp);
  }

  // -------------------------------------------------------------------------
  //
  // transforming expression by replacing function calls by contracts
  //
  // -------------------------------------------------------------------------
  
  /***************************************************************************
   * Transform expression
   * @param exp the expression 
   * @return the transformed result.
   **************************************************************************/
  private Expression transform(Expression exp)
  {
    return UseContracts.execute(exp, fun, callers);
  }
       
  /***************************************************************************
   * Transform quantified variable
   * @param qvar the quantified variable
   * @return the transformed result.
   **************************************************************************/
  private QuantifiedVariable transform(QuantifiedVariable qvar)
  {
    Expression exp = qvar.exp == null ? null : transform(qvar.exp);
    return new QuantifiedVariable(transform(qvar.qvcore), exp);
  }
  
  /***************************************************************************
   * Transform quantified variable cores
   * @param qv the quantified variable cores
   * @return the transformed result.
   **************************************************************************/
  private List<QuantifiedVariableCore> transform(QuantifiedVariableCore[] qv)
  {
    List<QuantifiedVariableCore> qv0 = new ArrayList<QuantifiedVariableCore>();
    for (QuantifiedVariableCore q : qv)
      qv0.add(transform(q));
    return qv0;
  }
  
  /***************************************************************************
   * Transform quantified variable core
   * @param exp the quantified variable core
   * @return the transformed result.
   **************************************************************************/
  private QuantifiedVariableCore transform(QuantifiedVariableCore qv)
  {
    if (qv instanceof QuantifiedVariableCore.IdentifierTypeQuantifiedVar)
      return qv;
    QuantifiedVariableCore.IdentifierSetQuantifiedVar qv0 =
        (QuantifiedVariableCore.IdentifierSetQuantifiedVar)qv;
    return new QuantifiedVariableCore.IdentifierSetQuantifiedVar(qv0.ident,
        transform(qv0.exp));
  }
  
  /***************************************************************************
   * Transform binder
   * @param binder the binder
   * @return the transformed result.
   **************************************************************************/
  private Binder transform(Binder binder)
  {
    return new Binder(binder.ident, transform(binder.exp));
  }
}
//---------------------------------------------------------------------------
// end of file
//---------------------------------------------------------------------------